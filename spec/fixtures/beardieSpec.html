<div id="beardie">

    <!-- Load from object object -->
    <!-- instead of passing the scope here just register as string - expect a function to be returned which
        can call the callback with the scope name . E.g. it can call the callback with different scope names -->
    <div id="loadFromObject" canny-mod="beardie" canny-var="{'bind':'scope', 'to':'canny.beardieSample.data3'}">
        <p>Hello I'm <strong>{{scope.user.name}}</strong> and I'm <strong>{{scope.user.age}}</strong> years old.</p>
        <p>And this expression should stay: {{scopeX.foo}}.</p>
        <div canny-mod="beardie" canny-var="canny.beardieSample.data4">
            <p>Hello I'm {{scope2.name}} and I'm {{scope2.age}} years old.</p>
        </div>
    </div>
    <!-- test static object in HTML -->
    <div id="loadFromStaticObject" canny-mod="beardie" canny-var="{'bind':'scope','to':{'message':'my text'}}">
        <p>DATA: {{scope.message}}</p>
    </div>

    <!-- test static object in HTML -->
    <div id="checkIfPropertyIsUndefined" canny-mod="beardie" canny-var="canny.beardieSample.custom.beardie">
        <p class="{{scope.attrUndefined}}">{{scope.messageUndefined}}</p>
        <p class="{{scope.attr}}">{{scope.message}}</p>
    </div>

    <div id="checkAttributes" canny-mod="beardie" canny-var="{'bind':'scope', 'to':'canny.beardieSample.attributes'}">
        <div id="{{scope.id}}" class="{{scope.testClass}}"></div>
        <div canny-mod="beardie" canny-var="canny.beardieSample.attributes2">
            <p class="test {{scope2.testClass}}">test</p>
        </div>
    </div>

    <!-- call back function will be called with multiple scopes -->
    <div id="supportMultipleScopes" canny-mod="beardie" canny-var="canny.beardieSample.supportScopes">
        <div id="{{scope1.id}}" class="{{scope1.testClass}}">foo {{scope1.text}}</div>
        <div id="{{scope2.id}}" class="{{scope2.testClass}}">foo {{scope2.text}}</div>
        <div id="{{scope3.id}}" class="{{scope3.testClass}}">foo {{scope3.text}}</div>
    </div>

    <!--
        test that the dynamically change data works. If you call the callback again from beardie then it should update
        the data in the DOM.
     -->
    <div id="dynamicallyChangeData" canny-mod="beardie" canny-var="canny.beardieSample.dynamicallyChangeData.beardieAPI">
        <div id="{{scope.id}}">
            <p class="test with {{scope.className}}"></p>
        </div>
        <p class="{{scope.className}}">{{scope.text}}</p>
        <p>texts replace {{scope.text}} inside a text</p>

    </div>

    <!--
        Example needed to test side effects from "dynamicallyChangeData" test. It has the same scope name
        but it's not in the scope of "dynamicallyChangeData". So the data should NOT be updated if something
        changed in "dynamicallyChangeData".
    -->
    <div id="sameScopeShouldNotEffected" canny-mod="beardie" canny-var="canny.beardieSample.sameScopeShouldNotEffected">
        <div id="{{scope.id}}">
            <p class="test with {{scope.className}}"></p>
        </div>
        <p class="{{scope.className}}">{{scope.text}}</p>
        <p>texts replace {{scope.text}} inside a text</p>
    </div>


</div>